import{r as v,i as Dt}from"./iframe-DUxtTNxK.js";import{s as te}from"./index-0HEPybu3.js";const qt=0,Ht=1,kt=2,xt=3;var Pt=Object.prototype.hasOwnProperty;function mt(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&mt(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(Pt.call(t,n)&&++s&&!Pt.call(e,n)||!(n in e)||!mt(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const W=new WeakMap,j=()=>{},D=j(),ht=Object,i=t=>t===D,N=t=>typeof t=="function",U=(t,e)=>({...t,...e}),$t=t=>N(t.then),ut={},st={},Tt="undefined",Q=typeof window!=Tt,pt=typeof document!=Tt,ee=Q&&"Deno"in window,ne=()=>Q&&typeof window.requestAnimationFrame!=Tt,Bt=(t,e)=>{const n=W.get(t);return[()=>!i(e)&&t.get(e)||ut,s=>{if(!i(e)){const a=t.get(e);e in st||(st[e]=a),n[5](e,U(a,s),a||ut)}},n[6],()=>!i(e)&&e in st?st[e]:!i(e)&&t.get(e)||ut]};let gt=!0;const se=()=>gt,[wt,vt]=Q&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[j,j],re=()=>{const t=pt&&document.visibilityState;return i(t)||t!=="hidden"},oe=t=>(pt&&document.addEventListener("visibilitychange",t),wt("focus",t),()=>{pt&&document.removeEventListener("visibilitychange",t),vt("focus",t)}),ie=t=>{const e=()=>{gt=!0,t()},n=()=>{gt=!1};return wt("online",e),wt("offline",n),()=>{vt("online",e),vt("offline",n)}},ae={isOnline:se,isVisible:re},ce={initFocus:oe,initReconnect:ie},Wt=!Dt.useId,X=!Q||ee,ue=t=>ne()?window.requestAnimationFrame(t):setTimeout(t,1),lt=X?v.useEffect:v.useLayoutEffect,ft=typeof navigator<"u"&&navigator.connection,Mt=!X&&ft&&(["slow-2g","2g"].includes(ft.effectiveType)||ft.saveData),rt=new WeakMap,le=t=>ht.prototype.toString.call(t),dt=(t,e)=>t===`[object ${e}]`;let fe=0;const Ot=t=>{const e=typeof t,n=le(t),s=dt(n,"Date"),a=dt(n,"RegExp"),c=dt(n,"Object");let o,l;if(ht(t)===t&&!s&&!a){if(o=rt.get(t),o)return o;if(o=++fe+"~",rt.set(t,o),Array.isArray(t)){for(o="@",l=0;l<t.length;l++)o+=Ot(t[l])+",";rt.set(t,o)}if(c){o="#";const R=ht.keys(t).sort();for(;!i(l=R.pop());)i(t[l])||(o+=l+":"+Ot(t[l])+",");rt.set(t,o)}}else o=s?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return o},_t=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Ot(t):"",[t,e]};let de=0;const St=()=>++de;async function Kt(...t){const[e,n,s,a]=t,c=U({populateCache:!0,throwOnError:!0},typeof a=="boolean"?{revalidate:a}:a||{});let o=c.populateCache;const l=c.rollbackOnError;let R=c.optimisticData;const I=T=>typeof l=="function"?l(T):l!==!1,O=c.throwOnError;if(N(n)){const T=n,m=[],A=e.keys();for(const h of A)!/^\$(inf|sub)\$/.test(h)&&T(e.get(h)._k)&&m.push(h);return Promise.all(m.map(g))}return g(n);async function g(T){const[m]=_t(T);if(!m)return;const[A,h]=Bt(e,m),[ot,r,Z,J]=W.get(e),M=()=>{const _=ot[m];return(N(c.revalidate)?c.revalidate(A().data,T):c.revalidate!==!1)&&(delete Z[m],delete J[m],_&&_[0])?_[0](kt).then(()=>A().data):A().data};if(t.length<3)return M();let S=s,F,L=!1;const E=St();r[m]=[E,0];const k=!i(R),V=A(),$=V.data,tt=V._c,q=i(tt)?$:tt;if(k&&(R=N(R)?R(q,$):R,h({data:R,_c:q})),N(S))try{S=S(q)}catch(_){F=_,L=!0}if(S&&$t(S))if(S=await S.catch(_=>{F=_,L=!0}),E!==r[m][0]){if(L)throw F;return S}else L&&k&&I(F)&&(o=!0,h({data:q,_c:D}));if(o&&!L)if(N(o)){const _=o(S,q);h({data:_,error:D,_c:D})}else h({data:S,error:D,_c:D});if(r[m][1]=St(),Promise.resolve(M()).then(()=>{h({_c:D})}),L){if(O)throw F;return}return S}}const jt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Ee=(t,e)=>{if(!W.has(t)){const n=U(ce,e),s=Object.create(null),a=Kt.bind(D,t);let c=j;const o=Object.create(null),l=(O,g)=>{const T=o[O]||[];return o[O]=T,T.push(g),()=>T.splice(T.indexOf(g),1)},R=(O,g,T)=>{t.set(O,g);const m=o[O];if(m)for(const A of m)A(g,T)},I=()=>{if(!W.has(t)&&(W.set(t,[s,Object.create(null),Object.create(null),Object.create(null),a,R,l]),!X)){const O=n.initFocus(setTimeout.bind(D,jt.bind(D,s,qt))),g=n.initReconnect(setTimeout.bind(D,jt.bind(D,s,Ht)));c=()=>{O&&O(),g&&g(),W.delete(t)}}};return I(),[t,a,I,c]}return[t,W.get(t)[4]]},Re=(t,e,n,s,a)=>{const c=n.errorRetryCount,o=a.retryCount,l=~~((Math.random()+.5)*(1<<(o<8?o:8)))*n.errorRetryInterval;!i(c)&&o>c||setTimeout(s,l,a)},me=mt,[zt,he]=Ee(new Map),pe=U({onLoadingSlow:j,onSuccess:j,onError:j,onErrorRetry:Re,onDiscarded:j,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Mt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Mt?5e3:3e3,compare:me,isPaused:()=>!1,cache:zt,mutate:he,fallback:{}},ae),ge=(t,e)=>{const n=U(t,e);if(e){const{use:s,fallback:a}=t,{use:c,fallback:o}=e;s&&c&&(n.use=s.concat(c)),a&&o&&(n.fallback=U(a,o))}return n},we=v.createContext({}),ve="$inf$",Jt=Q&&window.__SWR_DEVTOOLS_USE__,Oe=Jt?window.__SWR_DEVTOOLS_USE__:[],Se=()=>{Jt&&(window.__SWR_DEVTOOLS_REACT__=Dt)},Gt=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],De=()=>{const t=v.useContext(we);return v.useMemo(()=>U(pe,t),[t])},Te=t=>(e,n,s)=>t(e,n&&((...c)=>{const[o]=_t(e),[,,,l]=W.get(zt);if(o.startsWith(ve))return n(...c);const R=l[o];return i(R)?n(...c):(delete l[o],R)}),s),_e=Oe.concat(Te),Ce=t=>function(...n){const s=De(),[a,c,o]=Gt(n),l=ge(s,o);let R=t;const{use:I}=l,O=(I||[]).concat(_e);for(let g=O.length;g--;)R=O[g](R);return R(a,c||l.fetcher||null,l)},ye=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const a=s.indexOf(n);a>=0&&(s[a]=s[s.length-1],s.pop())}},Ve=(t,e)=>(...n)=>{const[s,a,c]=Gt(n),o=(c.use||[]).concat(e);return t(s,a,{...c,use:o})};Se();const Et=Dt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),Rt={dedupe:!0},Ut=Promise.resolve(D),Ie=(t,e,n)=>{const{cache:s,compare:a,suspense:c,fallbackData:o,revalidateOnMount:l,revalidateIfStale:R,refreshInterval:I,refreshWhenHidden:O,refreshWhenOffline:g,keepPreviousData:T}=n,[m,A,h,ot]=W.get(s),[r,Z]=_t(t),J=v.useRef(!1),M=v.useRef(!1),S=v.useRef(r),F=v.useRef(e),L=v.useRef(n),E=()=>L.current,k=()=>E().isVisible()&&E().isOnline(),[V,$,tt,q]=Bt(s,r),_=v.useRef({}).current,G=i(o)?i(n.fallback)?D:n.fallback[r]:o,Ct=(u,d)=>{for(const p in _){const f=p;if(f==="data"){if(!a(u[f],d[f])&&(!i(u[f])||!a(nt,d[f])))return!1}else if(d[f]!==u[f])return!1}return!0},yt=v.useMemo(()=>{const u=!r||!e?!1:i(l)?E().isPaused()||c?!1:R!==!1:l,d=C=>{const x=U(C);return delete x._k,u?{isValidating:!0,isLoading:!0,...x}:x},p=V(),f=q(),b=d(p),z=p===f?b:d(f);let w=b;return[()=>{const C=d(V());return Ct(C,w)?(w.data=C.data,w.isLoading=C.isLoading,w.isValidating=C.isValidating,w.error=C.error,w):(w=C,C)},()=>z]},[s,r]),B=te.useSyncExternalStore(v.useCallback(u=>tt(r,(d,p)=>{Ct(p,d)||u()}),[s,r]),yt[0],yt[1]),It=!J.current,Yt=m[r]&&m[r].length>0,K=B.data,H=i(K)?G&&$t(G)?Et(G):G:K,et=B.error,it=v.useRef(H),nt=T?i(K)?i(it.current)?H:it.current:K:H,bt=Yt&&!i(et)?!1:It&&!i(l)?l:E().isPaused()?!1:c?i(H)?!1:R:i(H)||R,At=!!(r&&e&&It&&bt),Xt=i(B.isValidating)?At:B.isValidating,Qt=i(B.isLoading)?At:B.isLoading,Y=v.useCallback(async u=>{const d=F.current;if(!r||!d||M.current||E().isPaused())return!1;let p,f,b=!0;const z=u||{},w=!h[r]||!z.dedupe,C=()=>Wt?!M.current&&r===S.current&&J.current:r===S.current,x={isValidating:!1,isLoading:!1},Vt=()=>{$(x)},Nt=()=>{const y=h[r];y&&y[1]===f&&delete h[r]},Ft={isValidating:!0};i(V().data)&&(Ft.isLoading=!0);try{if(w&&($(Ft),n.loadingTimeout&&i(V().data)&&setTimeout(()=>{b&&C()&&E().onLoadingSlow(r,n)},n.loadingTimeout),h[r]=[d(Z),St()]),[p,f]=h[r],p=await p,w&&setTimeout(Nt,n.dedupingInterval),!h[r]||h[r][1]!==f)return w&&C()&&E().onDiscarded(r),!1;x.error=D;const y=A[r];if(!i(y)&&(f<=y[0]||f<=y[1]||y[1]===0))return Vt(),w&&C()&&E().onDiscarded(r),!1;const P=V().data;x.data=a(P,p)?P:p,w&&C()&&E().onSuccess(p,r,n)}catch(y){Nt();const P=E(),{shouldRetryOnError:at}=P;P.isPaused()||(x.error=y,w&&C()&&(P.onError(y,r,P),(at===!0||N(at)&&at(y))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||k())&&P.onErrorRetry(y,r,P,Zt=>{const ct=m[r];ct&&ct[0]&&ct[0](xt,Zt)},{retryCount:(z.retryCount||0)+1,dedupe:!0})))}return b=!1,Vt(),!0},[r,s]),Lt=v.useCallback((...u)=>Kt(s,S.current,...u),[]);if(lt(()=>{F.current=e,L.current=n,i(K)||(it.current=K)}),lt(()=>{if(!r)return;const u=Y.bind(D,Rt);let d=0;E().revalidateOnFocus&&(d=Date.now()+E().focusThrottleInterval);const f=ye(r,m,(b,z={})=>{if(b==qt){const w=Date.now();E().revalidateOnFocus&&w>d&&k()&&(d=w+E().focusThrottleInterval,u())}else if(b==Ht)E().revalidateOnReconnect&&k()&&u();else{if(b==kt)return Y();if(b==xt)return Y(z)}});return M.current=!1,S.current=r,J.current=!0,$({_k:Z}),bt&&(h[r]||(i(H)||X?u():ue(u))),()=>{M.current=!0,f()}},[r]),lt(()=>{let u;function d(){const f=N(I)?I(V().data):I;f&&u!==-1&&(u=setTimeout(p,f))}function p(){!V().error&&(O||E().isVisible())&&(g||E().isOnline())?Y(Rt).then(d):d()}return d(),()=>{u&&(clearTimeout(u),u=-1)}},[I,O,g,r]),v.useDebugValue(nt),c){const u=r&&i(H);if(!Wt&&X&&u)throw new Error("Fallback data is required when using Suspense in SSR.");u&&(F.current=e,L.current=n,M.current=!1);const d=ot[r],p=!i(d)&&u?Lt(d):Ut;if(Et(p),!i(et)&&u)throw et;const f=u?Y(Rt):Ut;!i(nt)&&u&&(f.status="fulfilled",f.value=!0),Et(f)}return{mutate:Lt,get data(){return _.data=!0,nt},get error(){return _.error=!0,et},get isValidating(){return _.isValidating=!0,Xt},get isLoading(){return _.isLoading=!0,Qt}}},Ne=Ce(Ie);export{Wt as I,D as U,De as a,lt as b,St as g,U as m,_t as s,Ne as u,Ve as w};
